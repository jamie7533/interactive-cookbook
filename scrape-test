from recipe_scrapers import scrape_me
from ytSearch import search_youtube
#from parse_ingredients import parse_ingredient
from ingredient_parser import parse_ingredient
#from nltk.parse import ShiftReduceParser
import spacy
from spacy import displacy
from step import Step

nlp = spacy.load("en_core_web_sm")
#sample_sentence = "Cover the baking dish tightly with aluminum foil and bake until the chicken and rice are cooked through, about 1 hour and 25 minutes"
#sample_sentence = "In a large bowl, combine the ground chuck, onion mixture, bread crumbs, and eggs, and mix lightly with a fork"
sample_sentence = "Cover the baking dish tightly with aluminum foil and bake until the chicken and rice are cooked through, about 1 hour and 25 minutes. A pan of hot water in the oven, under the meat loaf, will keep the top from cracking"
doc = nlp(sample_sentence)

print ("{:<15} | {:<8} | {:<15} | {:<20}".format('Token','Relation','Head', 'Children'))
print ("-" * 70)

for token in doc:
  # Print the token, dependency nature, head and all dependents of the token
  print ("{:<15} | {:<8} | {:<15} | {:<20}"
         .format(str(token.text), str(token.dep_), str(token.head.text), str([child for child in token.children])))
# scraper = scrape_me('https://www.spicetheplate.com/pork/korean-style-pan-fried-pork-belly/', wild_mode=True)
# scraper = scrape_me('https://www.foodnetwork.com/recipes/ina-garten/meat-loaf-recipe-1921718')

# divide larger steps into sentences
# for each sentence, use the dependency parser
# if there is no 'nsubj' (token.dep_) and a ROOT is found, that ROOT is an imperative/command --> therefore the sentence is a step
# ----- ROOT = cooking action
# if we find one with 'nsub', append it to the last step so far

### testing
# long_step = "In a large bowl, combine the ground chuck, onion mixture, bread crumbs, and eggs, and mix lightly with a fork. Don't mash or the meat loaf will be dense. Shape the mixture into a rectangular loaf on a sheet pan covered with parchment paper. Spread the ketchup evenly on top. Bake for 1 to 1 1/4 hours, until the internal temperature is 160 degrees F and the meat loaf is cooked through. (A pan of hot water in the oven, under the meat loaf, will keep the top from cracking.) Serve hot."
# shorter_steps = long_step.split('.')
# annotated_steps = []
# for step in shorter_steps:
#     annotated_step = Step(text=step)
#     annotated_step.parse_text = nlp(step)
#     action = None
#     nsubj_exists = False
#     # lst_relations = [str(token.dep_) for token in doc]
#     # if 'nsubj' in lst_relations:
#     #     # append to previous step
#     # else:
        
#     #     # find root, add to list of steps
#     for token in doc:
#         relation = str(token.dep_)
#         if relation == 'nsubj': 
#             nsubj_exists = True
#             break
#         if relation == 'ROOT': 
#             action = str(token.text)
    
#     if nsubj_exists

### GLOBAL VARIABLES ###
scraper = None
ingredients = None
parsed_ingredients = []
steps = None
parsed_steps = None
currentStep = 0
#step = ["text", "ingredients", "tools", "duration"]
def scrape(url):
    global scraper, ingredients, parsed_ingredients, steps, parsed_steps
    scraper = scrape_me(url, wild_mode=True)

    ingredients = scraper.ingredients()

    #print(parse_ingredient(ingredients[0]))
    steps = scraper.instructions_list()

    for i in ingredients:
        parsed_ingredients.append(parse_ingredient(i)) # if only a comment, remove from ingredients

def answer(question):
    pass

def main():
    #global scraper, ingredients, steps
    #create regex for commands that have inputs
    commands = {"ingredients": "get list of ingredients", 
                "instructions": "get list of instructions", 
                "help": "get list of commands",
                "substution [ingredient]": "get possible substutions for an ingredient", 
                "how do I do [action]": "get link to youtube tutorial",
                "how much [ingredient]": "get quantity needed for ingredient",
                "what is [ingredient/tool]": "get image of query", #maybe dictionary entry?/image search
                "next": "show the next step",
                "previous": "show the previous step",
                "repeat": "show the current step",
                "start over": "go to the first step",
                "stop": "exit the current recipe"}#add further commands as needed 
    input_flag = 1
    url = input("Please enter a url: ")
    scrape(url)
    print("Enter \'ingredients\' to get the list of ingredients")
    print("Enter \'instructions\' to list all instructions")
    print("Enter \'help\' for a list of commands")
    while(input_flag == 1):
       
        user = input("Please enter a command, type help for a list of available commands: ")
        if user == 'ingredients':
            print(parsed_ingredients)
        elif user == 'instructions':
            print(steps)
        elif user == 'help':
            print(commands)
        else:
            answer(user)
        
        cont = input("Do you want to continue y/n: ")

        if cont == 'y':
            continue
        if cont == 'n':
            print("Terminated")
            inputflag -= 1
            break

if __name__ == '__main__':
    main()